### **1. 데이터 확인 테스트**

#### **1.1 각 테이블의 데이터 확인**
1. 직급 데이터 확인
   ```sql
   SELECT * FROM Roles;
   ```

2. 직원 데이터 확인
   ```sql
   SELECT * FROM Employees;
   ```

3. 재료 데이터 확인
   ```sql
   SELECT * FROM Ingredients;
   ```

4. 상품 데이터 확인
   ```sql
   SELECT * FROM Products;
   ```

5. 판매 데이터 확인
   ```sql
   SELECT * FROM Sales;
   ```

#### **1.2 테이블 간 관계 확인**

1. `Employees`와 `Roles` 관계 확인
   ```sql
   SELECT e.name AS employee_name, r.role_name
   FROM Employees e
   JOIN Roles r ON e.role_id = r.role_id;
   ```

2. `Ingredients`와 `Ingredient_Categories` 관계 확인
   ```sql
   SELECT i.name AS ingredient_name, c.category_name
   FROM Ingredients i
   JOIN Ingredient_Categories c ON i.category_id = c.category_id;
   ```

3. `Products`와 `Product_Ingredients` 관계 확인
   ```sql
   SELECT p.name AS product_name, i.name AS ingredient_name, pi.required_amount
   FROM Product_Ingredients pi
   JOIN Products p ON pi.product_id = p.product_id
   JOIN Ingredients i ON pi.ingredient_id = i.ingredient_id;
   ```

------

### **2. 트리거 테스트**

#### **2.1 판매 → 재고 감소**

1. 판매 삽입
   ```sql
   INSERT INTO Sales (sale_id, product_id, sale_date, quantity, total_price)
   VALUES (sale_seq.NEXTVAL, 1, SYSDATE, 2, 10000); -- 치즈버거 2개 판매
   ```

2. 재고 확인
   ```sql
   SELECT s.ingredient_id, s.current_stock, i.name
   FROM Stock s
   JOIN Ingredients i ON s.ingredient_id = i.ingredient_id;
   ```

3. 재고 기록 확인
   ```sql
   SELECT * FROM Stock_Logs WHERE reason = '판매로 인한 감소';
   ```

#### **2.2 주문 → 재고 증가**

1. 주문 삽입
   ```sql
   INSERT INTO Orders (order_id, ingredient_id, supplier, order_date, quantity, total_price)
   VALUES (order_seq.NEXTVAL, 3, '육류 공급사 B', SYSDATE, 50, 75000);
   ```

2. 재고 확인
   ```sql
   SELECT s.ingredient_id, s.current_stock, i.name
   FROM Stock s
   JOIN Ingredients i ON s.ingredient_id = i.ingredient_id;
   ```

3. 재고 기록 확인
   ```sql
   SELECT * FROM Stock_Logs WHERE reason = '주문으로 인한 증가';
   ```

------

### **3. 보고서 데이터 테스트**

#### **3.1 매출 보고서**

기간별 매출 합계:
```sql
SELECT TO_CHAR(s.sale_date, 'YYYY-MM-DD') AS sale_date,
       SUM(s.total_price) AS daily_sales
FROM Sales s
GROUP BY TO_CHAR(s.sale_date, 'YYYY-MM-DD')
ORDER BY sale_date;
```

#### **3.2 주문 내역 보고서**

```sql
SELECT TO_CHAR(o.order_date, 'YYYY-MM-DD') AS order_date,
       i.name AS ingredient_name,
       o.quantity,
       o.total_price
FROM Orders o
JOIN Ingredients i ON o.ingredient_id = i.ingredient_id
ORDER BY order_date;
```

#### **3.3 손익 계산서**

간단한 손익 계산 (매출 - 주문 비용):

```sql
SELECT (SELECT SUM(total_price) FROM Sales) AS total_sales,
       (SELECT SUM(total_price) FROM Orders) AS total_orders,
       (SELECT SUM(total_price) FROM Sales) - (SELECT SUM(total_price) FROM Orders) AS net_profit;
```

------

### **4. 시나리오 기반 테스트**

#### **시나리오 1: 상품 판매 시 재고가 줄어드는지 확인**

1. 재고 확인:

   ```sql
   SELECT s.ingredient_id, s.current_stock, i.name
   FROM Stock s
   JOIN Ingredients i ON s.ingredient_id = i.ingredient_id;
   ```

2. 판매 삽입:

   ```sql
   INSERT INTO Sales (sale_id, product_id, sale_date, quantity, total_price)
   VALUES (sale_seq.NEXTVAL, 2, SYSDATE, 3, 16500); -- 불고기버거 3개 판매
   ```

3. 재고 확인:

   ```sql
   SELECT s.ingredient_id, s.current_stock, i.name
   FROM Stock s
   JOIN Ingredients i ON s.ingredient_id = i.ingredient_id;
   ```

#### **시나리오 2: 주문 시 재고가 증가하는지 확인**

1. 주문 삽입:

   ```sql
   INSERT INTO Orders (order_id, ingredient_id, supplier, order_date, quantity, total_price)
   VALUES (order_seq.NEXTVAL, 1, '채소 공급사 A', SYSDATE, 100, 20000);
   ```

2. 재고 확인:

   ```sql
   SELECT s.ingredient_id, s.current_stock, i.name
   FROM Stock s
   JOIN Ingredients i ON s.ingredient_id = i.ingredient_id;
   ```

------

### **5. 오류 처리 테스트**

1. **외래 키 무결성 테스트**:

   ```sql
   INSERT INTO Sales (sale_id, product_id, sale_date, quantity, total_price)
   VALUES (sale_seq.NEXTVAL, 999, SYSDATE, 1, 5000); -- 존재하지 않는 product_id
   ```

   예상 결과: `ORA-02291: integrity constraint violated`.

2. **재고 부족 시 테스트**:

   ```sql
   INSERT INTO Sales (sale_id, product_id, sale_date, quantity, total_price)
   VALUES (sale_seq.NEXTVAL, 1, SYSDATE, 1000, 500000); -- 과도한 판매량
   ```

   예상 결과: 재고 감소 로직에서 오류.
