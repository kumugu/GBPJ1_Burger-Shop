# 1. 시퀀스 생성
```sql
-- 1. 직원 테이블 시퀀스
CREATE SEQUENCE employee_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 2. 직급 테이블 시퀀스
CREATE SEQUENCE role_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 3. 재료 테이블 시퀀스
CREATE SEQUENCE ingredient_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 4. 재료 카테고리 테이블 시퀀스
CREATE SEQUENCE ingredient_category_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 5. 상품 테이블 시퀀스
CREATE SEQUENCE product_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 6. 상품 카테고리 테이블 시퀀스
CREATE SEQUENCE product_category_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 7. 주문 테이블 시퀀스
CREATE SEQUENCE order_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 8. 판매 테이블 시퀀스
CREATE SEQUENCE sale_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 9. 급여 테이블 시퀀스
CREATE SEQUENCE salary_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 10. 재고 기록 테이블 시퀀스
CREATE SEQUENCE stock_log_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 11. 메뉴 테이블 시퀀스
CREATE SEQUENCE menu_seq START WITH 1 INCREMENT BY 1 NOCACHE;

-- 12. 손익 계산서 테이블 시퀀스
CREATE SEQUENCE profit_loss_report_seq START WITH 1 INCREMENT BY 1 NOCACHE;

```


# 2. 테이블 생성
```sql
-- 1. 직급 테이블
CREATE TABLE Roles (
    role_id NUMBER PRIMARY KEY,
    role_name VARCHAR2(50) NOT NULL
);

-- 2. 직원 테이블
CREATE TABLE Employees (
    employee_id NUMBER PRIMARY KEY,
    password_hash VARCHAR2(255) NOT NULL,
    name VARCHAR2(100) NOT NULL,
    contact VARCHAR2(15),
    hire_date DATE DEFAULT SYSDATE,
    role_id NUMBER NOT NULL,
    CONSTRAINT fk_employee_role FOREIGN KEY (role_id)
        REFERENCES Roles(role_id)
);

-- 3. 재료 카테고리 테이블
CREATE TABLE Ingredient_Categories (
    category_id NUMBER PRIMARY KEY,
    category_name VARCHAR2(100) NOT NULL
);

-- 4. 재료 테이블
CREATE TABLE Ingredients (
    ingredient_id NUMBER PRIMARY KEY,
    category_id NUMBER NOT NULL,
    name VARCHAR2(100) NOT NULL,
    unit_price NUMBER NOT NULL,
    unit VARCHAR2(20) NOT NULL,
    CONSTRAINT fk_ingredient_category FOREIGN KEY (category_id)
        REFERENCES Ingredient_Categories(category_id)
);

-- 5. 상품 카테고리 테이블
CREATE TABLE Product_Categories (
    category_id NUMBER PRIMARY KEY,
    category_name VARCHAR2(100) NOT NULL
);

-- 6. 상품 테이블
CREATE TABLE Products (
    product_id NUMBER PRIMARY KEY,
    category_id NUMBER NOT NULL,
    name VARCHAR2(100) NOT NULL,
    price NUMBER NOT NULL,
    cost_price NUMBER,
    CONSTRAINT fk_product_category FOREIGN KEY (category_id)
        REFERENCES Product_Categories(category_id)
);

-- 7. 상품-재료 매핑 테이블
CREATE TABLE Product_Ingredients (
    product_id NUMBER NOT NULL,
    ingredient_id NUMBER NOT NULL,
    required_amount NUMBER NOT NULL,
    CONSTRAINT pk_prod_ing PRIMARY KEY (product_id, ingredient_id),
    CONSTRAINT fk_prod_ing_product FOREIGN KEY (product_id)
        REFERENCES Products(product_id),
    CONSTRAINT fk_prod_ing_ingredient FOREIGN KEY (ingredient_id)
        REFERENCES Ingredients(ingredient_id)
);

-- 8. 재고 테이블
CREATE TABLE Stock (
    ingredient_id NUMBER PRIMARY KEY,
    current_stock NUMBER DEFAULT 0,
    CONSTRAINT fk_stock_ingredient FOREIGN KEY (ingredient_id)
        REFERENCES Ingredients(ingredient_id)
);

-- 9. 재고 기록 테이블
CREATE TABLE Stock_Logs (
    stock_log_id NUMBER PRIMARY KEY,
    ingredient_id NUMBER NOT NULL,
    change_amount NUMBER NOT NULL,
    log_date DATE DEFAULT SYSDATE,
    reason VARCHAR2(255),
    CONSTRAINT fk_stock_log_ingredient FOREIGN KEY (ingredient_id)
        REFERENCES Ingredients(ingredient_id)
);

-- 10. 주문 테이블
CREATE TABLE Orders (
    order_id NUMBER PRIMARY KEY,
    ingredient_id NUMBER NOT NULL,
    supplier VARCHAR2(100),
    order_date DATE DEFAULT SYSDATE,
    quantity NUMBER NOT NULL,
    total_price NUMBER NOT NULL,
    CONSTRAINT fk_order_ingredient FOREIGN KEY (ingredient_id)
        REFERENCES Ingredients(ingredient_id)
);

-- 11. 판매 테이블
CREATE TABLE Sales (
    sale_id NUMBER PRIMARY KEY,
    product_id NUMBER NOT NULL,
    sale_date DATE DEFAULT SYSDATE,
    quantity NUMBER NOT NULL,
    total_price NUMBER NOT NULL,
    CONSTRAINT fk_sale_product FOREIGN KEY (product_id)
        REFERENCES Products(product_id)
);

-- 12. 급여 테이블
CREATE TABLE Salaries (
    salary_id NUMBER PRIMARY KEY,
    employee_id NUMBER NOT NULL,
    payment_date DATE DEFAULT SYSDATE,
    payment_amount NUMBER NOT NULL,
    payment_type VARCHAR2(50),
    CONSTRAINT fk_salary_employee FOREIGN KEY (employee_id)
        REFERENCES Employees(employee_id)
);

-- 13. 메뉴 테이블
CREATE TABLE Menu (
    menu_id NUMBER PRIMARY KEY,
    product_id NUMBER NOT NULL,
    display_order NUMBER NOT NULL,
    is_visible CHAR(1) DEFAULT 'Y',
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
);

-- 14. 손익 계산서 테이블
CREATE TABLE ProfitLossReport (
    report_id NUMBER PRIMARY KEY,
    report_date DATE,
    total_sales_revenue NUMBER,
    total_product_cost NUMBER,
    total_ingredient_cost NUMBER,
    total_salary_expenses NUMBER,
    total_profit NUMBER
);
```


# 3. 트리거 생성
```sql
-- 1. 손익 계산서 ID 자동 설정 트리거
CREATE OR REPLACE TRIGGER trigger_profit_loss_report
BEFORE INSERT ON ProfitLossReport
FOR EACH ROW
BEGIN
    :NEW.report_id := profit_loss_report_seq.NEXTVAL;
END;
/

-- 2. 판매 시 재고 감소 트리거
CREATE OR REPLACE TRIGGER update_stock_after_sale
AFTER INSERT ON Sales
FOR EACH ROW
BEGIN
    FOR r IN (
        SELECT ingredient_id, required_amount * :NEW.quantity AS total_amount
        FROM Product_Ingredients
        WHERE product_id = :NEW.product_id
    ) LOOP
        UPDATE Stock
        SET current_stock = current_stock - r.total_amount
        WHERE ingredient_id = r.ingredient_id;

        INSERT INTO Stock_Logs (stock_log_id, ingredient_id, change_amount, log_date, reason)
        VALUES (stock_log_seq.NEXTVAL, r.ingredient_id, -r.total_amount, SYSDATE, '판매 감소');
    END LOOP;
END;
/

-- 3. 손익 계산서 동기화 트리거
CREATE OR REPLACE TRIGGER trigger_update_profit_loss_sales
AFTER INSERT OR UPDATE ON Sales
FOR EACH ROW
BEGIN
    MERGE INTO ProfitLossReport pl
    USING (
        SELECT
            TRUNC(:NEW.sale_date, 'MONTH') AS report_month,
            SUM(s.total_price) AS total_sales_revenue,
            SUM(p.cost_price * s.quantity) AS total_product_cost
        FROM Sales s
        JOIN Products p ON s.product_id = p.product_id
        WHERE TRUNC(s.sale_date, 'MONTH') = TRUNC(:NEW.sale_date, 'MONTH')
        GROUP BY TRUNC(s.sale_date, 'MONTH')
    ) new_data
    ON (pl.report_date = new_data.report_month)
    WHEN MATCHED THEN
        UPDATE SET
            pl.total_sales_revenue = new_data.total_sales_revenue,
            pl.total_product_cost = new_data.total_product_cost
    WHEN NOT MATCHED THEN
        INSERT (pl.report_date, pl.total_sales_revenue, pl.total_product_cost, 0, 0, 0)
        VALUES (new_data.report_month, new_data.total_sales_revenue, new_data.total_product_cost, 0, 0, 0);
END;
/
```



```sql
-- 1. 기존 트리거 삭제
DROP TRIGGER IF EXISTS trigger_update_profit_loss_sales;
DROP TRIGGER IF EXISTS trigger_update_profit_loss_orders;
DROP TRIGGER IF EXISTS trigger_update_profit_loss_salaries;
DROP TRIGGER IF EXISTS trigger_calculate_profit_loss;

-- 2. 기존 테이블 삭제
DROP TABLE IF EXISTS ProfitLossReport CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Stock_Logs CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Stock CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Orders CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Sales CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Ingredients CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Product_Ingredients CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Products CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Product_Categories CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Ingredient_Categories CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Employees CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Roles CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Salaries CASCADE CONSTRAINTS;
DROP TABLE IF EXISTS Menu CASCADE CONSTRAINTS;

-- 3. 기존 시퀀스 삭제
DROP SEQUENCE IF EXISTS profit_loss_report_seq;
DROP SEQUENCE IF EXISTS stock_log_seq;
DROP SEQUENCE IF EXISTS sale_seq;
DROP SEQUENCE IF EXISTS order_seq;
DROP SEQUENCE IF EXISTS product_category_seq;
DROP SEQUENCE IF EXISTS product_seq;
DROP SEQUENCE IF EXISTS ingredient_category_seq;
DROP SEQUENCE IF EXISTS ingredient_seq;
DROP SEQUENCE IF EXISTS role_seq;
DROP SEQUENCE IF EXISTS employee_seq;
DROP SEQUENCE IF EXISTS menu_seq;
```
